/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : cURL
 #	author : miyako
 #	2015/01/23
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"
#include "curl.h"
#include "libjson/libjson.h"

std::map<uint32_t, uint32_t> _curl_write_method_ids;
std::map<uint32_t, uint32_t> _curl_read_method_ids;
std::map<uint32_t, uint32_t> _curl_debug_method_ids;
std::map<uint32_t, uint32_t> _curl_progress_method_ids;
std::map<uint32_t, uint32_t> _curl_header_method_ids;

std::map<uint32_t, CUTF16String> _curl_write_method_names;
std::map<uint32_t, CUTF16String> _curl_read_method_names;
std::map<uint32_t, CUTF16String> _curl_debug_method_names;
std::map<uint32_t, CUTF16String> _curl_progress_method_names;
std::map<uint32_t, CUTF16String> _curl_header_method_names;

std::map<uint32_t, uint32_t> _curl_progress_ids;

#if VERSIONMAC
std::map<uint32_t, CUTF8String> _curl_input_paths;
std::map<uint32_t, CUTF8String> _curl_output_paths;
#else
std::map<uint32_t, CUTF16String> _curl_input_paths;
std::map<uint32_t, CUTF16String> _curl_output_paths;
#endif
std::map<uint32_t, long> _curl_input_positions;

#pragma mark Modifled API

CURLcode curl_easy_perform_with_yield(CURL *easy, void (*_PA_YieldAbsolute)(void));

/*
void getFormFileName(CUTF8String &formFile, CUTF8String &formFileName)
{
#if VERSIONWIN
	//utf-8 to utf-16
	int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)formFile.c_str(), formFile.size(), NULL, 0);
	if(len)
	{
		std::vector<char> buf((len + 1) * sizeof(wchar_t));
		if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)formFile.c_str(), formFile.size(), (LPWSTR)&buf[0], 0))
		{
			wchar_t	fDrive[_MAX_DRIVE],
			fDir[_MAX_DIR],
			fName[_MAX_FNAME],
			fExt[_MAX_EXT];
			_wsplitpath_s((const wchar_t *)&buf[0], fDrive, fDir, fName, fExt);
			std::wstring _fileName = fName;
			_fileName += fExt;
			//utf-16 to utf-8
			len = WideCharToMultiByte(CP_UTF8, 0, _fileName.c_str(), _fileName.size(), NULL, 0, NULL, NULL);
			if(len)
			{
				std::vector<char> buf(len + 1);
				if(WideCharToMultiByte(CP_UTF8, 0, _fileName.c_str(), _fileName.size(), (LPSTR)&buf[0], len, NULL, NULL))
				{
					formFileName = CUTF8String((const uint8_t *)&buf[0]);
				}
			}
		}
	}
#else
	NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, (const char *)formFile.c_str());
	formFileName = CUTF8String((const uint8_t *)[[filePath lastPathComponent]fileSystemRepresentation]);
	[filePath release];
#endif
}
 */
#pragma mark Callbacks

size_t _cURL_write_data(void *buffer, size_t size, size_t nmemb, C_BLOB &outData){
    
    PA_YieldAbsolute();
	
		uint32_t processId = PA_GetCurrentProcessNumber();
		size_t len = size * nmemb;
	
#if VERSIONMAC
	std::map<uint32_t, CUTF8String>::iterator ppos = _curl_output_paths.find(processId);
#else
	std::map<uint32_t, CUTF16String>::iterator ppos = _curl_output_paths.find(processId);
#endif
	
	if(ppos != _curl_output_paths.end())
	{//out to file
#if VERSIONMAC
		CUTF8String path = ppos->second;
#else
		CUTF16String path = ppos->second;
#endif
#if VERSIONMAC
		FILE *f = fopen ((const char *)path.c_str(), "ab");
#else
		FILE *f = _wfopen ((const wchar_t *)path.c_str(), L"ab");
#endif
		if(f)
		{
			fwrite(buffer, size, nmemb, f);
			fclose(f);
		}
	}else{
		outData.addBytes((const uint8_t *)buffer, len);
	}
	
    std::map<uint32_t, uint32_t>::iterator pos = _curl_write_method_ids.find(processId);
    if(pos != _curl_write_method_ids.end()) {
        uint32_t _curl_write_method_id = pos->second;
        if(_curl_write_method_id)
				{
            if(!PA_IsProcessDying()){
                PA_Variable	params[2];
                params[0] = PA_CreateVariable(eVK_Longint);
                params[1] = PA_CreateVariable(eVK_Longint);
                PA_SetLongintVariable(&params[0], len);
                PA_SetLongintVariable(&params[1], outData.getBytesLength());
							
                PA_Variable statusCode = PA_ExecuteMethodByID(_curl_write_method_id, params, 2);
							
                if(PA_GetVariableKind(statusCode) == eVK_Boolean){
                    if(PA_GetBooleanVariable(statusCode)){
                        if(len){len=0;}else{len=1;}
                    }
                }
                PA_ClearVariable(&params[0]);
                PA_ClearVariable(&params[1]);
            }
				}
		}else{
			std::map<uint32_t, CUTF16String>::iterator upos = _curl_write_method_names.find(processId);
			if(upos != _curl_write_method_names.end()) {
				CUTF16String _curl_write_method_name = upos->second;
				if(_curl_write_method_name.length())
				{
					if(!PA_IsProcessDying()){
						PA_Variable	params[4];
						params[2] = PA_CreateVariable(eVK_Longint);
						params[3] = PA_CreateVariable(eVK_Longint);
						PA_SetLongintVariable(&params[2], len);
						PA_SetLongintVariable(&params[3], outData.getBytesLength());
						
						params[0] = PA_CreateVariable(eVK_Unistring);
						PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)_curl_write_method_name.c_str());
						PA_SetStringVariable(&params[0], &_methodName);
						
						params[1] = PA_CreateVariable(eVK_Boolean);
						PA_SetBooleanVariable(&params[1], false);
						
						PA_ExecuteCommandByID(1007, params, 4);
						
						if(PA_GetBooleanVariable(params[1])){
							if(len){len=0;}else{len=1;}
						}
						PA_ClearVariable(&params[0]);
						PA_ClearVariable(&params[1]);
						PA_ClearVariable(&params[2]);
						PA_ClearVariable(&params[3]);
					}
				}
			}
		}
	
    return len;
}

size_t _cURL_header_data(void *buffer, size_t size, size_t nmemb, void *userdata){
    
    PA_YieldAbsolute();
    
    size_t len = size * nmemb;
    
    uint32_t processId = PA_GetCurrentProcessNumber();
    uint32_t _curl_header_method_id = 0;
    
    std::map<uint32_t, uint32_t>::iterator pos = _curl_header_method_ids.find(processId);
    
    if(pos != _curl_header_method_ids.end()) {
        _curl_header_method_id = pos->second;
        if(_curl_header_method_id){
            if(!PA_IsProcessDying()){
                PA_Variable	params[1];
                params[0] = PA_CreateVariable(eVK_Blob);
                PA_SetBlobVariable(&params[0], buffer, len);
							
                PA_Variable statusCode = PA_ExecuteMethodByID(_curl_header_method_id, params, 1);
							
                if(PA_GetVariableKind(statusCode) == eVK_Boolean){
                    if(PA_GetBooleanVariable(statusCode)){
                        if(len){len=0;}else{len=1;}
                    }
                }
                PA_ClearVariable(&params[0]);
//                PA_ClearVariable(&params[1]);
            }
        }
		}else{
			std::map<uint32_t, CUTF16String>::iterator upos = _curl_header_method_names.find(processId);
			if(upos != _curl_header_method_names.end()) {
				CUTF16String _curl_header_method_name = upos->second;
				if(_curl_header_method_name.length())
				{
					if(!PA_IsProcessDying()){
						PA_Variable	params[3];
						params[2] = PA_CreateVariable(eVK_Blob);
						PA_SetBlobVariable(&params[0], buffer, len);
						
						params[0] = PA_CreateVariable(eVK_Unistring);
						PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)_curl_header_method_name.c_str());
						PA_SetStringVariable(&params[0], &_methodName);
						
						params[1] = PA_CreateVariable(eVK_Boolean);
						PA_SetBooleanVariable(&params[1], false);
						
						PA_ExecuteCommandByID(1007, params, 3);
						
						if(PA_GetBooleanVariable(params[1])){
							if(len){len=0;}else{len=1;}
						}
						PA_ClearVariable(&params[0]);
						PA_ClearVariable(&params[1]);
						PA_ClearVariable(&params[2]);
					}
				}
			}
		}
			
    return len;
}

size_t _cURL_debug_data(CURL *_curl, curl_infotype infoType, char * buffer, size_t bufferLen, void *userData){
    
    size_t result = 0;
    PA_YieldAbsolute();
    
    uint32_t processId = PA_GetCurrentProcessNumber();
    uint32_t _curl_debug_method_id = 0;
    
    std::map<uint32_t, uint32_t>::iterator pos = _curl_debug_method_ids.find(processId);
    
    if(pos != _curl_debug_method_ids.end()) {
        _curl_debug_method_id = pos->second;
        if(_curl_debug_method_id){
            if(!PA_IsProcessDying()){
                PA_Variable	params[2];
                params[0] = PA_CreateVariable(eVK_Longint);
                params[1] = PA_CreateVariable(eVK_Blob);
                PA_SetLongintVariable(&params[0], infoType);
                PA_SetBlobVariable(&params[1], buffer, bufferLen);
							
                PA_Variable statusCode = PA_ExecuteMethodByID(_curl_debug_method_id, params, 2);
							
                if(PA_GetVariableKind(statusCode) == eVK_Boolean){
                    if(PA_GetBooleanVariable(statusCode)){
                        result = 1;
                    }
                }
                PA_ClearVariable(&params[0]);
                PA_ClearVariable(&params[1]);
            }
        }
		}else{
			std::map<uint32_t, CUTF16String>::iterator upos = _curl_debug_method_names.find(processId);
			if(upos != _curl_debug_method_names.end()) {
				CUTF16String _curl_debug_method_name = upos->second;
				if(_curl_debug_method_name.length())
				{
					if(!PA_IsProcessDying()){
						PA_Variable	params[4];
						params[2] = PA_CreateVariable(eVK_Longint);
						params[3] = PA_CreateVariable(eVK_Blob);
						PA_SetLongintVariable(&params[0], infoType);
						PA_SetBlobVariable(&params[1], buffer, bufferLen);
						
						params[0] = PA_CreateVariable(eVK_Unistring);
						PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)_curl_debug_method_name.c_str());
						PA_SetStringVariable(&params[0], &_methodName);
						
						params[1] = PA_CreateVariable(eVK_Boolean);
						PA_SetBooleanVariable(&params[1], false);
						
						PA_ExecuteCommandByID(1007, params, 4);
						
						if(PA_GetBooleanVariable(params[1])){
							result = 1;
						}
						PA_ClearVariable(&params[0]);
						PA_ClearVariable(&params[1]);
						PA_ClearVariable(&params[2]);
						PA_ClearVariable(&params[3]);
					}
				}
			}
		}
			
    return result;
}

size_t _cURL_read_data(void *buffer, size_t size, size_t nmemb, C_BLOB &inData){
    
	PA_YieldAbsolute();

	uint32_t processId = PA_GetCurrentProcessNumber();
	size_t len = size * nmemb;
	
#if VERSIONMAC
	std::map<uint32_t, CUTF8String>::iterator ppos = _curl_input_paths.find(processId);
#else
	std::map<uint32_t, CUTF16String>::iterator ppos = _curl_input_paths.find(processId);
#endif
	std::map<uint32_t, long>::iterator lpos = _curl_input_positions.find(processId);
	
	if((ppos != _curl_input_paths.end()) && (lpos != _curl_input_positions.end()))
	{//out to file
#if VERSIONMAC
		CUTF8String path = ppos->second;
#else
		CUTF16String path = ppos->second;
#endif
		;
		
#if VERSIONMAC
		FILE *f = fopen ((const char *)path.c_str(), "rb");
#else
		FILE *f = _wfopen ((const wchar_t *)path.c_str(), L"rb");
#endif
		if(f)
		{
			fseek(f, lpos->second, SEEK_SET);
			len = fread(buffer, size, nmemb, f);
			lpos->second += len;
			fclose(f);
		}
	}else{
		const uint8_t *ptr = inData.getBytesPtrForSize((uint32_t *)&len);
		if(ptr) memcpy(buffer, ptr, len);
		
	}
	
    uint32_t _curl_read_method_id = 0;
    
    std::map<uint32_t, uint32_t>::iterator pos = _curl_read_method_ids.find(processId);
    
    if(pos != _curl_read_method_ids.end()) {
        _curl_read_method_id = pos->second;
        if(_curl_read_method_id){
            if(!PA_IsProcessDying()){
                PA_Variable	params[2];
                params[0] = PA_CreateVariable(eVK_Longint);
                params[1] = PA_CreateVariable(eVK_Longint);
                PA_SetLongintVariable(&params[0], len);
                PA_SetLongintVariable(&params[1], inData.getBytesLength());
							
                PA_Variable statusCode = PA_ExecuteMethodByID(_curl_read_method_id, params, 2);
							
                if(PA_GetVariableKind(statusCode) == eVK_Boolean){
                    if(PA_GetBooleanVariable(statusCode)){
                        if(len){len=0;}else{len=1;}
                    }
                }
                PA_ClearVariable(&params[0]);
                PA_ClearVariable(&params[1]);
            }
        }
		}else{
			std::map<uint32_t, CUTF16String>::iterator upos = _curl_read_method_names.find(processId);
			if(upos != _curl_read_method_names.end()) {
				CUTF16String _curl_read_method_name = upos->second;
				if(_curl_read_method_name.length())
				{
					if(!PA_IsProcessDying()){
						PA_Variable	params[4];
						params[2] = PA_CreateVariable(eVK_Longint);
						params[3] = PA_CreateVariable(eVK_Longint);
						PA_SetLongintVariable(&params[2], len);
						PA_SetLongintVariable(&params[3], inData.getBytesLength());
						
						params[0] = PA_CreateVariable(eVK_Unistring);
						PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)_curl_read_method_name.c_str());
						PA_SetStringVariable(&params[0], &_methodName);
						
						params[1] = PA_CreateVariable(eVK_Boolean);
						PA_SetBooleanVariable(&params[1], false);
						
						PA_ExecuteCommandByID(1007, params, 4);
						
						if(PA_GetBooleanVariable(params[1])){
							if(len){len=0;}else{len=1;}
						}
						PA_ClearVariable(&params[0]);
						PA_ClearVariable(&params[1]);
						PA_ClearVariable(&params[2]);
						PA_ClearVariable(&params[3]);
					}
				}
			}
		}
			
    return len;
}

size_t _cURL_xfer_data(void *buffer,   curl_off_t dltotal,   curl_off_t dlnow,   curl_off_t ultotal,   curl_off_t ulnow)
{
    size_t result = 0;
    PA_YieldAbsolute();
    
    uint32_t processId = PA_GetCurrentProcessNumber();
    uint32_t _curl_progress_id = 0;
    uint32_t _curl_progress_method_id = 0;
    
    std::map<uint32_t, uint32_t>::iterator pos = _curl_progress_ids.find(processId);
    
    if(pos != _curl_progress_ids.end()) {
        _curl_progress_id = pos->second;
    }
    
    pos = _curl_progress_method_ids.find(processId);
    
    if(pos != _curl_progress_method_ids.end()) {
        _curl_progress_method_id = pos->second;
        if(_curl_progress_method_id){
        
            if(!PA_IsProcessDying()){
                PA_Variable	params[5];
                params[0] = PA_CreateVariable(eVK_Longint);
                params[1] = PA_CreateVariable(eVK_Longint);
                params[2] = PA_CreateVariable(eVK_Longint);
                params[3] = PA_CreateVariable(eVK_Longint);
                params[4] = PA_CreateVariable(eVK_Longint);
                PA_SetLongintVariable(&params[0], _curl_progress_id);
                PA_SetLongintVariable(&params[1], dltotal);
                PA_SetLongintVariable(&params[2], dlnow);
                PA_SetLongintVariable(&params[3], ultotal);
                PA_SetLongintVariable(&params[4], ulnow);
							
                PA_Variable statusCode = PA_ExecuteMethodByID(_curl_progress_method_id, params, 5);
							
                if(PA_GetVariableKind(statusCode) == eVK_Boolean){
                    if(PA_GetBooleanVariable(statusCode)){
                        result = 1;
                    }
                }
                //impossible to catch aborted trace!!
                /*
                if(PA_IsProcessDying()){
                    result = 1;
                }
                C_TEXT processName;
                PA_long32 processState;
                PA_long32 processTime;
                PA_GetProcessInfo(processId, processName, &processState, &processTime);
                if(processState < 0)
                {
                    result = 1;
                }
                 */
                PA_ClearVariable(&params[0]);
                PA_ClearVariable(&params[1]);
                PA_ClearVariable(&params[2]);
                PA_ClearVariable(&params[3]);
                PA_ClearVariable(&params[4]);
            }
        }
		}else{
			std::map<uint32_t, CUTF16String>::iterator upos = _curl_progress_method_names.find(processId);
			if(upos != _curl_progress_method_names.end()) {
				CUTF16String _curl_progress_method_name = upos->second;
				if(_curl_progress_method_name.length())
				{
					if(!PA_IsProcessDying()){
						PA_Variable	params[7];
						params[2] = PA_CreateVariable(eVK_Longint);
						params[3] = PA_CreateVariable(eVK_Longint);
						params[4] = PA_CreateVariable(eVK_Longint);
						params[5] = PA_CreateVariable(eVK_Longint);
						params[6] = PA_CreateVariable(eVK_Longint);
						PA_SetLongintVariable(&params[0], _curl_progress_id);
						PA_SetLongintVariable(&params[1], dltotal);
						PA_SetLongintVariable(&params[2], dlnow);
						PA_SetLongintVariable(&params[3], ultotal);
						PA_SetLongintVariable(&params[4], ulnow);
						
						params[0] = PA_CreateVariable(eVK_Unistring);
						PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)_curl_progress_method_name.c_str());
						PA_SetStringVariable(&params[0], &_methodName);
						
						params[1] = PA_CreateVariable(eVK_Boolean);
						PA_SetBooleanVariable(&params[1], false);
						
						PA_ExecuteCommandByID(1007, params, 7);
						
						if(PA_GetBooleanVariable(params[1])){
							result = 1;
						}
						PA_ClearVariable(&params[0]);
						PA_ClearVariable(&params[1]);
						PA_ClearVariable(&params[2]);
						PA_ClearVariable(&params[3]);
						PA_ClearVariable(&params[4]);
						PA_ClearVariable(&params[5]);
						PA_ClearVariable(&params[6]);
					}
				}
			}
		}
	
    return result;
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		switch(pProcNum)
		{
				// --- cURL
				
			case 1 :
				_cURL(params, false);
				break;
				
			case 7 :
				_cURL(params, true);
				break;
				
			default:
				CommandDispatcher(pProcNum, pResult, pParams);
				break;
		}
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- cURL
		case 2 :
			cURL_Escape_url(pResult, pParams);
			break;

		case 3 :
			cURL_Unescape_url(pResult, pParams);
			break;

		case 4 :
			cURL_Get_version(pResult, pParams);
			break;

		case 5 :
			cURL_Get_date(pResult, pParams);
			break;

		case 6 :
			cURL_Get_executable(pResult, pParams);
			break;
	}
}

// ------------------------------------- cURL -------------------------------------

#pragma mark -

#pragma mark cURL

void setArrayParameter(PA_Variable *param, PackagePtr pParams, unsigned int i)
{
	PA_Variable *p = ((PA_Variable *)pParams[i-1]);
	p->fType = param->fType;
	p->fFiller = param->fFiller;
	p->uValue.fArray.fCurrent = param->uValue.fArray.fCurrent;
	p->uValue.fArray.fNbElements = param->uValue.fArray.fNbElements;
	p->uValue.fArray.fData = param->uValue.fArray.fData;
	
	PA_Handle h = p->uValue.fArray.fData;
	int x = sizeof(PA_Blob);
	int y = (param->uValue.fArray.fNbElements)+1;
	PA_SetHandleSize(h, x * y);
}

#pragma mark JSON

void json_conv(const char *value, std::wstring &u32)
{
	if(value)
	{
		C_TEXT t;
		CUTF8String u8;
		
		u8 = (const uint8_t *)value;
		t.setUTF8String(&u8);
		
#if VERSIONWIN
		u32 = std::wstring((wchar_t *)t.getUTF16StringPtr());
#else
		
		uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
		std::vector<char> buf(dataSize);
		
		PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
															 t.getUTF16Length() * sizeof(PA_Unichar),
															 eVTC_UTF_16,
															 (char *)&buf[0],
															 dataSize,
															 eVTC_UTF_32);
		
		u32 = std::wstring((wchar_t *)&buf[0]);
#endif
	}else
	{
		u32 = L"";
	}
	
}

void json_set_text(JSONNODE *n, const wchar_t *name, char *value)
{
	if(n)
	{
		std::wstring w32;
		json_conv(value, w32);
		json_push_back(n, json_new_a(name, w32.c_str()));
	}
}


void json_set_number(JSONNODE *n, const wchar_t *name, json_int_t value)
{
	if(n)
	{
		json_push_back(n, json_new_i(name, value));
	}
}

void getInfo(CURL *curl, C_TEXT &json)
{
	long responseCode, connectCode, fileTime, redirectCount, headerSize, requestSize, lastSocket;
	long sslVerifyResult, localPort, primaryPort, numConnects, osErrNo, httpAuthAvail, proxyAuthAvail;
	double totalTime, nameLookupTime, connectTime, appConnectTime, preTransferTime, startTransferTime, redirectTime;
	double sizeUpload, speedUpload, sizeDownload, speedDownload, contentLengthDownload, contentLengthUpload;
	long rtspClientCseq, rtspServerCseq, rtspCseqRecv, conditionUnmet;
	char *effectiveUrl = NULL;
	char *redirectUrl = NULL;
	char *contentType = NULL;
	char *ftpEntryPath = NULL;
	char *localIp = NULL;
	char *primaryIp = NULL;
	char *rtspSessionId = NULL;
	
	JSONNODE *info = json_new(JSON_NODE);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &conditionUnmet))
		json_set_number(info, L"conditionUnmet", conditionUnmet);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_UPLOAD, &contentLengthUpload))
		json_set_number(info, L"contentLengthUpload", contentLengthUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CLIENT_CSEQ, &rtspClientCseq))
		json_set_number(info, L"rtspClientCseq", rtspClientCseq);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SERVER_CSEQ, &rtspServerCseq))
		json_set_number(info, L"rtspServerCseq", rtspServerCseq);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CSEQ_RECV, &rtspCseqRecv))
		json_set_number(info, L"rtspCseqRecv", rtspCseqRecv);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, &lastSocket))
		json_set_number(info, L"lastSocket", lastSocket);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT, &primaryPort))
		json_set_number(info, L"primaryPort", primaryPort);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &localPort))
		json_set_number(info, L"localPort", localPort);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &contentLengthDownload))
		json_set_number(info, L"contentLengthDownload", contentLengthDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE, &connectCode))
		json_set_number(info, L"connectCode", connectCode);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &fileTime))
		json_set_number(info, L"fileTime", fileTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &totalTime))
		json_set_number(info, L"totalTime", totalTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE , &requestSize))
		json_set_number(info, L"requestSize", requestSize);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &headerSize))
		json_set_number(info, L"headerSize", headerSize);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &speedUpload))
		json_set_number(info, L"speedUpload", speedUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD, &speedDownload))
		json_set_number(info, L"speedDownload", speedDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &sizeDownload))
		json_set_number(info, L"sizeDownload", sizeDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &sizeUpload))
		json_set_number(info, L"sizeUpload", sizeUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTPAUTH_AVAIL, &httpAuthAvail))
		json_set_number(info, L"httpAuthAvail", httpAuthAvail);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXYAUTH_AVAIL, &proxyAuthAvail))
		json_set_number(info, L"proxyAuthAvail", proxyAuthAvail);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_OS_ERRNO, &osErrNo))
		json_set_number(info, L"osErrNo", osErrNo);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &numConnects))
		json_set_number(info, L"numConnects", numConnects);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &responseCode))
		json_set_number(info, L"responseCode", responseCode);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME, &nameLookupTime))
		json_set_number(info, L"nameLookupTime", nameLookupTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &connectTime))
		json_set_number(info, L"connectTime", connectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME, &appConnectTime))
		json_set_number(info, L"appConnectTime", appConnectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME, &preTransferTime))
		json_set_number(info, L"preTransferTime", preTransferTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME, &startTransferTime))
		json_set_number(info, L"startTransferTime", startTransferTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME, &redirectTime))
		json_set_number(info, L"redirectTime", redirectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT , &sslVerifyResult))
		json_set_number(info, L"sslVerifyResult", sslVerifyResult);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &redirectCount))
		json_set_number(info, L"redirectCount", redirectCount);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &effectiveUrl)))
		json_set_text(info, L"effectiveUrl", effectiveUrl);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_IP, &localIp)))
		json_set_text(info, L"localIp", localIp);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &contentType)))
		json_set_text(info, L"contentType", contentType);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &primaryIp)))
		json_set_text(info, L"primaryIp", primaryIp);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &redirectUrl)))
		json_set_text(info, L"redirectUrl", redirectUrl);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &ftpEntryPath)))
		json_set_text(info, L"ftpEntryPath", ftpEntryPath);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SESSION_ID, &rtspSessionId)))
		json_set_text(info, L"rtspSessionId", rtspSessionId);
	
	/*
	 CURLINFO_SSL_ENGINES
	 CURLINFO_COOKIELIST
	 CURLINFO_CERTINFO
	 CURLINFO_TLS_SESSION
	 CURLINFO_PRIVATE
	 */
	
	json_char *json_string = json_write_formatted(info);
	std::wstring wstr = std::wstring(json_string);
	
#if VERSIONWIN
	json.setUTF16String((const PA_Unichar *)wstr.c_str(), (uint32_t)wstr.length());
#else
	uint32_t dataSize = (wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar);
	std::vector<char> buf(dataSize);
	
	uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																						wstr.length() * sizeof(wchar_t),
																						eVTC_UTF_32,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_16);
	
	json.setUTF16String((const PA_Unichar *)&buf[0], len);
#endif
	
	json_delete(info);
}

void getInfo(CURL *curl, ARRAY_TEXT &json)
{
	long responseCode, connectCode, fileTime, redirectCount, headerSize, requestSize, lastSocket;
	long sslVerifyResult, localPort, primaryPort, numConnects, osErrNo, httpAuthAvail, proxyAuthAvail;
	double totalTime, nameLookupTime, connectTime, appConnectTime, preTransferTime, startTransferTime, redirectTime;
	double sizeUpload, speedUpload, sizeDownload, speedDownload, contentLengthDownload, contentLengthUpload;
	long rtspClientCseq, rtspServerCseq, rtspCseqRecv, conditionUnmet;
	char *effectiveUrl = NULL;
	char *redirectUrl = NULL;
	char *contentType = NULL;
	char *ftpEntryPath = NULL;
	char *localIp = NULL;
	char *primaryIp = NULL;
	char *rtspSessionId = NULL;
	
	JSONNODE *info = json_new(JSON_NODE);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &conditionUnmet))
		json_set_number(info, L"conditionUnmet", conditionUnmet);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_UPLOAD, &contentLengthUpload))
		json_set_number(info, L"contentLengthUpload", contentLengthUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CLIENT_CSEQ, &rtspClientCseq))
		json_set_number(info, L"rtspClientCseq", rtspClientCseq);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SERVER_CSEQ, &rtspServerCseq))
		json_set_number(info, L"rtspServerCseq", rtspServerCseq);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CSEQ_RECV, &rtspCseqRecv))
		json_set_number(info, L"rtspCseqRecv", rtspCseqRecv);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, &lastSocket))
		json_set_number(info, L"lastSocket", lastSocket);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT, &primaryPort))
		json_set_number(info, L"primaryPort", primaryPort);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &localPort))
		json_set_number(info, L"localPort", localPort);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &contentLengthDownload))
		json_set_number(info, L"contentLengthDownload", contentLengthDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE, &connectCode))
		json_set_number(info, L"connectCode", connectCode);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &fileTime))
		json_set_number(info, L"fileTime", fileTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &totalTime))
		json_set_number(info, L"totalTime", totalTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE , &requestSize))
		json_set_number(info, L"requestSize", requestSize);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &headerSize))
		json_set_number(info, L"headerSize", headerSize);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &speedUpload))
		json_set_number(info, L"speedUpload", speedUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD, &speedDownload))
		json_set_number(info, L"speedDownload", speedDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &sizeDownload))
		json_set_number(info, L"sizeDownload", sizeDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &sizeUpload))
		json_set_number(info, L"sizeUpload", sizeUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTPAUTH_AVAIL, &httpAuthAvail))
		json_set_number(info, L"httpAuthAvail", httpAuthAvail);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXYAUTH_AVAIL, &proxyAuthAvail))
		json_set_number(info, L"proxyAuthAvail", proxyAuthAvail);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_OS_ERRNO, &osErrNo))
		json_set_number(info, L"osErrNo", osErrNo);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &numConnects))
		json_set_number(info, L"numConnects", numConnects);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &responseCode))
		json_set_number(info, L"responseCode", responseCode);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME, &nameLookupTime))
		json_set_number(info, L"nameLookupTime", nameLookupTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &connectTime))
		json_set_number(info, L"connectTime", connectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME, &appConnectTime))
		json_set_number(info, L"appConnectTime", appConnectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME, &preTransferTime))
		json_set_number(info, L"preTransferTime", preTransferTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME, &startTransferTime))
		json_set_number(info, L"startTransferTime", startTransferTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME, &redirectTime))
		json_set_number(info, L"redirectTime", redirectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT , &sslVerifyResult))
		json_set_number(info, L"sslVerifyResult", sslVerifyResult);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &redirectCount))
		json_set_number(info, L"redirectCount", redirectCount);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &effectiveUrl)))
		json_set_text(info, L"effectiveUrl", effectiveUrl);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_IP, &localIp)))
		json_set_text(info, L"localIp", localIp);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &contentType)))
		json_set_text(info, L"contentType", contentType);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &primaryIp)))
		json_set_text(info, L"primaryIp", primaryIp);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &redirectUrl)))
		json_set_text(info, L"redirectUrl", redirectUrl);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &ftpEntryPath)))
		json_set_text(info, L"ftpEntryPath", ftpEntryPath);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SESSION_ID, &rtspSessionId)))
		json_set_text(info, L"rtspSessionId", rtspSessionId);
	
	/*
	 CURLINFO_SSL_ENGINES
	 CURLINFO_COOKIELIST
	 CURLINFO_CERTINFO
	 CURLINFO_TLS_SESSION
	 CURLINFO_PRIVATE
	 */
	
	json_char *json_string = json_write_formatted(info);
	std::wstring wstr = std::wstring(json_string);
	
#if VERSIONWIN
	json.appendUTF16String((const PA_Unichar *)wstr.c_str(), (uint32_t)wstr.length());
#else
	uint32_t dataSize = (wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar);
	std::vector<char> buf(dataSize);
	
	uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																						wstr.length() * sizeof(wchar_t),
																						eVTC_UTF_32,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_16);
	
	json.appendUTF16String((const PA_Unichar *)&buf[0], len);
#endif
	
	json_delete(info);
}

#pragma mark -

void _cURL(PA_PluginParameters params, bool multi)
{
	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
	PackagePtr pParams = (PackagePtr)params->fParameters;
	
	//common
	ARRAY_LONGINT Param2Keys;
	ARRAY_TEXT Param3Values;
	Param2Keys.fromParamAtIndex(pParams, 2);
	Param3Values.fromParamAtIndex(pParams, 3);

	//single
	C_TEXT Param1Url;
	C_BLOB Param4InData;
	C_BLOB Param5OutData;
	C_TEXT Param6Info;
	C_LONGINT returnValue;

	//multi
	ARRAY_TEXT Param1Urls;
	PA_Variable *Param4;
	PA_Variable Param5;
	ARRAY_TEXT Param6Infos;
	ARRAY_LONGINT Param7Errors;

	uint32_t processId = (uint32_t)PA_GetCurrentProcessNumber();
	
	CURL *curl = curl_easy_init();
	CURLcode error = CURLE_OK;
    
	if(curl)
	{
		curl_off_t inFileSize = 0;
	
		curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1);
		
		struct curl_slist *values_CURLOPT_MAIL_RCPT = NULL;
		struct curl_slist *values_CURLOPT_QUOTE = NULL;
		struct curl_slist *values_CURLOPT_POSTQUOTE = NULL;
		struct curl_slist *values_CURLOPT_PREQUOTE = NULL;
		struct curl_slist *values_CURLOPT_RESOLVE = NULL;
		struct curl_slist *values_CURLOPT_HTTP200ALIASES = NULL;
		struct curl_slist *values_CURLOPT_HTTPHEADER = NULL;
	
		struct curl_httppost *post_CURLOPT_HTTPPOST = NULL;
		struct curl_httppost *last_CURLOPT_HTTPPOST = NULL;
        
		if(Param2Keys.getSize() == Param3Values.getSize())
		{
			CURLoption option;
			CUTF8String value;
			CUTF16String methodName;
			uint32_t _curl_write_method_id;
			uint32_t _curl_read_method_id;
			uint32_t _curl_debug_method_id;
			uint32_t _curl_progress_id;
			uint32_t _curl_progress_method_id;
			uint32_t _curl_header_method_id;
		
			for(unsigned int i = 0; i < Param2Keys.getSize(); ++i)
			{
				option = (CURLoption)Param2Keys.getIntValueAtIndex(i);
				Param3Values.copyUTF8StringAtIndex(&value, i);
				
				switch (option)
				{
					case 0://typically element #0 of array
					case CURLOPT_URL:
						break;
					case 1://CURLOPT_WRITEDATA
						if(!multi)
						{
							//file path (out)
#if VERSIONMAC
							Param3Values.copyPathAtIndex(&value, i);
							_curl_output_paths.insert(std::map<uint32_t, CUTF8String>::value_type(processId, value));
#else
							Param3Values.copyUTF16StringAtIndex(&methodName, i);
							_curl_output_paths.insert(std::map<uint32_t, CUTF16String>::value_type(processId, methodName));
#endif
						}
						break;
					case 9://CURLOPT_READDATA
						if(!multi)
						{
							//file path (in)
							{
#if VERSIONMAC
								Param3Values.copyPathAtIndex(&value, i);
								FILE *f = fopen ((const char *)value.c_str(), "rb");
#else
								Param3Values.copyUTF16StringAtIndex(&methodName, i);
								FILE *f = _wfopen ((const wchar_t *)methodName.c_str(), L"rb");
#endif
								if(f)
								{
									fseek(f, 0L, SEEK_END);
									inFileSize = (curl_off_t)ftell(f);
									fclose(f);
									if(inFileSize)
									{
										curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, inFileSize);
									}
								}
#if VERSIONMAC
								_curl_input_paths.insert(std::map<uint32_t, CUTF8String>::value_type(processId, value));
#else
								_curl_input_paths.insert(std::map<uint32_t, CUTF16String>::value_type(processId, methodName));
#endif
							}
							_curl_input_positions.insert(std::map<uint32_t, long>::value_type(processId, 0));
						}
						break;
					case 94://CURLOPT_DEBUGFUNCTION
						Param3Values.copyUTF16StringAtIndex(&methodName, i);
						_curl_debug_method_id = PA_GetMethodID((PA_Unichar *)methodName.c_str());
						if(_curl_debug_method_id){
							curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);
							curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, _cURL_debug_data);
							_curl_debug_method_ids.insert(std::map<uint32_t, uint32_t>::value_type(processId, _curl_debug_method_id));
						}else if(methodName.length()){
							curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);
							curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, _cURL_debug_data);
							_curl_debug_method_names.insert(std::map<uint32_t, CUTF16String>::value_type(processId, methodName));
						}
						break;
					case 11://CURLOPT_WRITEFUNCTION
						Param3Values.copyUTF16StringAtIndex(&methodName, i);
						_curl_write_method_id = PA_GetMethodID((PA_Unichar *)methodName.c_str());
						if(_curl_write_method_id){
							_curl_write_method_ids.insert(std::map<uint32_t, uint32_t>::value_type(processId, _curl_write_method_id));
						}else if(methodName.length()){
							_curl_write_method_names.insert(std::map<uint32_t, CUTF16String>::value_type(processId, methodName));
						}
						break;
					case 12://CURLOPT_READFUNCTION
						Param3Values.copyUTF16StringAtIndex(&methodName, i);
						_curl_read_method_id = PA_GetMethodID((PA_Unichar *)methodName.c_str());
						if(_curl_read_method_id){
							_curl_read_method_ids.insert(std::map<uint32_t, uint32_t>::value_type(processId, _curl_read_method_id));
						}else if(methodName.length()){
							_curl_read_method_names.insert(std::map<uint32_t, CUTF16String>::value_type(processId, methodName));
						}
						break;
					case 57://CURLOPT_XFERINFODATA
						_curl_progress_id = atoi((const char *)value.c_str());
						_curl_progress_ids.insert(std::map<uint32_t, uint32_t>::value_type(processId, _curl_progress_id));
						break;
					case 219://CURLOPT_XFERINFOFUNCTION
						Param3Values.copyUTF16StringAtIndex(&methodName, i);
						_curl_progress_method_id = PA_GetMethodID((PA_Unichar *)methodName.c_str());
						if(_curl_progress_method_id){
							curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0);
							curl_easy_setopt(curl, CURLOPT_XFERINFOFUNCTION, _cURL_xfer_data);
							_curl_progress_method_ids.insert(std::map<uint32_t, uint32_t>::value_type(processId, _curl_progress_method_id));
						}else if(methodName.length()){
							curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0);
							curl_easy_setopt(curl, CURLOPT_XFERINFOFUNCTION, _cURL_xfer_data);
							_curl_progress_method_names.insert(std::map<uint32_t, CUTF16String>::value_type(processId, methodName));
						}
						break;
					case 79://CURLOPT_HEADERFUNCTION
						Param3Values.copyUTF16StringAtIndex(&methodName, i);
						_curl_header_method_id = PA_GetMethodID((PA_Unichar *)methodName.c_str());
						if(_curl_header_method_id){
							curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, _cURL_header_data);
							_curl_header_method_ids.insert(std::map<uint32_t, uint32_t>::value_type(processId, _curl_header_method_id));
						}else if(methodName.length()){
							curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, _cURL_header_data);
							_curl_header_method_names.insert(std::map<uint32_t, CUTF16String>::value_type(processId, methodName));
						}
						break;
					case 30://CURLOPT_HTTPPOST_FILE
						if(!multi)
						{
							size_t p = 0;
							size_t n = value.find_first_of((const uint8_t *)";", p);
							if(n != CUTF8String::npos)
							{
								CUTF8String formName = value.substr(p, n - p);
								p = n + 1;
								n = value.find_first_of((const uint8_t *)";", p);
								if(n != CUTF8String::npos)
								{
									CUTF8String formType = value.substr(p, n - p);
									p = n + 1;
									n = value.length();
									CUTF8String formFile = value.substr(p, n - p);
									//CUTF8String formFileName;
									//getFormFileName(formFile, formFileName);
									
									curl_formadd(&post_CURLOPT_HTTPPOST,
															 &last_CURLOPT_HTTPPOST,
															 CURLFORM_COPYNAME, formName.c_str(),
															 CURLFORM_CONTENTTYPE, formType.c_str(),
															 CURLFORM_FILE, formFile.c_str(),
															 //CURLFORM_FILENAME, formFileName.c_str(),
															 CURLFORM_END);
									
									if(post_CURLOPT_HTTPPOST){
										//disable the HTTP 1.1 Expect header for multipart post
										curl_easy_setopt(curl, CURLOPT_HTTPPOST, post_CURLOPT_HTTPPOST);
										values_CURLOPT_HTTPHEADER = curl_slist_append(values_CURLOPT_HTTPHEADER,
																																	(const char *)"Expect:");
									}
								}
							}
						}
						break;
					case 24://CURLOPT_HTTPPOST
						if(!multi)
						{
							size_t p = 0;
							size_t n = value.find_first_of((const uint8_t *)";", p);
							if(n != CUTF8String::npos)
							{
								CUTF8String formName = value.substr(p, n - p);
								p = n + 1;
								n = value.find_first_of((const uint8_t *)";", p);
								if(n != CUTF8String::npos)
								{
									CUTF8String formType = value.substr(p, n - p);
									p = n + 1;
									n = value.length();
									CUTF8String formData = value.substr(p, n - p);
									
									curl_formadd(&post_CURLOPT_HTTPPOST,
															 &last_CURLOPT_HTTPPOST,
															 CURLFORM_COPYNAME, formName.c_str(),
															 CURLFORM_CONTENTTYPE, formType.c_str(),
															 CURLFORM_COPYCONTENTS, formData.c_str(),
															 CURLFORM_END);
									
									if(post_CURLOPT_HTTPPOST){
										//disable the HTTP 1.1 Expect header for multipart post
										curl_easy_setopt(curl, CURLOPT_HTTPPOST, post_CURLOPT_HTTPPOST);
										values_CURLOPT_HTTPHEADER = curl_slist_append(values_CURLOPT_HTTPHEADER,
																																	(const char *)"Expect:");
									}
								}
							}
						}
						break;
					case 15://CURLOPT_HTTP_METHOD_OVERRIDE
						values_CURLOPT_HTTPHEADER = curl_slist_append(values_CURLOPT_HTTPHEADER, (const char *)(CUTF8String((const uint8_t *)"X-HTTP-Method-Override: ") + value).c_str());
						break;
					case 2://CURLOPT_AUTHORIZATION
						values_CURLOPT_HTTPHEADER = curl_slist_append(values_CURLOPT_HTTPHEADER, (const char *)(CUTF8String((const uint8_t *)"Authorization: ") + value).c_str());
						break;
					case 23://CURLOPT_HTTPHEADER
						values_CURLOPT_HTTPHEADER = curl_slist_append(values_CURLOPT_HTTPHEADER, (const char *)value.c_str());
						break;
					case 8://CURLOPT_HTTP_CONTENT_TYPE
						values_CURLOPT_HTTPHEADER = curl_slist_append(values_CURLOPT_HTTPHEADER, (const char *)(CUTF8String((const uint8_t *)"Content-Type: ") + value).c_str());
						break;
					case 29://CURLOPT_HTTP_ACCEPT
						values_CURLOPT_HTTPHEADER = curl_slist_append(values_CURLOPT_HTTPHEADER, (const char *)(CUTF8String((const uint8_t *)"Accept: ") + value).c_str());
						break;
					case 10://CURLOPT_HTTP_EXPECT
						values_CURLOPT_HTTPHEADER = curl_slist_append(values_CURLOPT_HTTPHEADER, (const char *)(CUTF8String((const uint8_t *)"Expect: ") + value).c_str());
						break;
						//integer options
					case 42://CURLOPT_HEADER:
						curl_easy_setopt(curl, CURLOPT_HEADER, atoi((const char *)value.c_str()));
						break;
					case 99://CURLOPT_NOSIGNAL:
						curl_easy_setopt(curl, CURLOPT_NOSIGNAL, atoi((const char *)value.c_str()));
						break;
					case 34://CURLOPT_TIMEVALUE:
						curl_easy_setopt(curl, CURLOPT_TIMEVALUE, atoi((const char *)value.c_str()));
						break;
					case 33://CURLOPT_TIMECONDITION:
						curl_easy_setopt(curl, CURLOPT_TIMECONDITION, atoi((const char *)value.c_str()));
						break;
					case 117://CURLOPT_MAXFILESIZE_LARGE:
						curl_easy_setopt(curl, CURLOPT_MAXFILESIZE_LARGE, atoi((const char *)value.c_str()));
						break;
					case 114://CURLOPT_MAXFILESIZE:
						curl_easy_setopt(curl, CURLOPT_MAXFILESIZE, atoi((const char *)value.c_str()));
						break;
					case 115://CURLOPT_INFILESIZE_LARGE:
						curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, atoi((const char *)value.c_str()));
						break;
					case 14://CURLOPT_INFILESIZE:
						curl_easy_setopt(curl, CURLOPT_INFILESIZE, atoi((const char *)value.c_str()));
						break;
					case 44://CURLOPT_NOBODY:
						curl_easy_setopt(curl, CURLOPT_NOBODY, atoi((const char *)value.c_str()));
						break;
					case 69://CURLOPT_FILETIME:
						curl_easy_setopt(curl, CURLOPT_FILETIME, atoi((const char *)value.c_str()));
						break;
					case 116://CURLOPT_RESUME_FROM_LARGE:
						curl_easy_setopt(curl, CURLOPT_RESUME_FROM_LARGE, atoi((const char *)value.c_str()));
						break;
					case 21://CURLOPT_RESUME_FROM:
						curl_easy_setopt(curl, CURLOPT_RESUME_FROM, atoi((const char *)value.c_str()));
						break;
					case 27://CURLOPT_CRLF:
						curl_easy_setopt(curl, CURLOPT_CRLF, atoi((const char *)value.c_str()));
						break;
					case 166://CURLOPT_PROXY_TRANSFER_MODE:
						curl_easy_setopt(curl, CURLOPT_PROXY_TRANSFER_MODE, atoi((const char *)value.c_str()));
						break;
					case 53://CURLOPT_TRANSFERTEXT:
						curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, atoi((const char *)value.c_str()));
						break;
					case 160://CURLOPT_NEW_DIRECTORY_PERMS:
						curl_easy_setopt(curl, CURLOPT_NEW_DIRECTORY_PERMS, atoi((const char *)value.c_str()));
						break;
					case 159://CURLOPT_NEW_FILE_PERMS:
						curl_easy_setopt(curl, CURLOPT_NEW_FILE_PERMS, atoi((const char *)value.c_str()));
						break;
					case 151://CURLOPT_SSH_AUTH_TYPES:
						curl_easy_setopt(curl, CURLOPT_SSH_AUTH_TYPES, atoi((const char *)value.c_str()));
						break;
					case 210://CURLOPT_GSSAPI_DELEGATION:
						curl_easy_setopt(curl, CURLOPT_GSSAPI_DELEGATION, atoi((const char *)value.c_str()));
						break;
					case 216://CURLOPT_SSL_OPTIONS:
						curl_easy_setopt(curl, CURLOPT_SSL_OPTIONS, atoi((const char *)value.c_str()));
						break;
					case 150://CURLOPT_SSL_SESSIONID_CACHE:
						curl_easy_setopt(curl, CURLOPT_SSL_SESSIONID_CACHE, atoi((const char *)value.c_str()));
						break;
					case 172://CURLOPT_CERTINFO:
						curl_easy_setopt(curl, CURLOPT_CERTINFO, atoi((const char *)value.c_str()));
						break;
					case 81://CURLOPT_SSL_VERIFYHOST:
						curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, atoi((const char *)value.c_str()));
						break;
					case 64://CURLOPT_SSL_VERIFYPEER:
						curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, atoi((const char *)value.c_str()));
						break;
					case 32://CURLOPT_SSLVERSION:
						curl_easy_setopt(curl, CURLOPT_SSLVERSION, atoi((const char *)value.c_str()));
						break;
					case 90://CURLOPT_SSLENGINE_DEFAULT:
						curl_easy_setopt(curl, CURLOPT_SSLENGINE_DEFAULT, atoi((const char *)value.c_str()));
						break;
					case 212://CURLOPT_ACCEPTTIMEOUT_MS:
						curl_easy_setopt(curl, CURLOPT_ACCEPTTIMEOUT_MS, atoi((const char *)value.c_str()));
						break;
					case 119://CURLOPT_USE_SSL:
						curl_easy_setopt(curl, CURLOPT_USE_SSL, atoi((const char *)value.c_str()));
						break;
					case 141://CURLOPT_CONNECT_ONLY:
						curl_easy_setopt(curl, CURLOPT_CONNECT_ONLY, atoi((const char *)value.c_str()));
						break;
					case 113://CURLOPT_IPRESOLVE:
						curl_easy_setopt(curl, CURLOPT_IPRESOLVE, atoi((const char *)value.c_str()));
						break;
					case 156://CURLOPT_CONNECTTIMEOUT_MS:
						curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, atoi((const char *)value.c_str()));
						break;
					case 78://CURLOPT_CONNECTTIMEOUT:
						curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, atoi((const char *)value.c_str()));
						break;
					case 75://CURLOPT_FORBID_REUSE:
						curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, atoi((const char *)value.c_str()));
						break;
					case 74://CURLOPT_FRESH_CONNECT:
						curl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, atoi((const char *)value.c_str()));
						break;
					case 71://CURLOPT_MAXCONNECTS:
						curl_easy_setopt(curl, CURLOPT_MAXCONNECTS, atoi((const char *)value.c_str()));
						break;
					case 146://CURLOPT_MAX_RECV_SPEED_LARGE:
						curl_easy_setopt(curl, CURLOPT_MAX_RECV_SPEED_LARGE, atoi((const char *)value.c_str()));
						break;
					case 145://CURLOPT_MAX_SEND_SPEED_LARGE:
						curl_easy_setopt(curl, CURLOPT_MAX_SEND_SPEED_LARGE, atoi((const char *)value.c_str()));
						break;
					case 20://CURLOPT_LOW_SPEED_TIME:
						curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, atoi((const char *)value.c_str()));
						break;
					case 19://CURLOPT_LOW_SPEED_LIMIT:
						curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, atoi((const char *)value.c_str()));
						break;
					case 155://CURLOPT_TIMEOUT_MS:
						curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, atoi((const char *)value.c_str()));
						break;
					case 13://CURLOPT_TIMEOUT:
						curl_easy_setopt(curl, CURLOPT_TIMEOUT, atoi((const char *)value.c_str()));
						break;
					case 189://CURLOPT_RTSP_REQUEST:
						curl_easy_setopt(curl, CURLOPT_RTSP_REQUEST, atoi((const char *)value.c_str()));
						break;
					case 193://CURLOPT_RTSP_CLIENT_CSEQ:
						curl_easy_setopt(curl, CURLOPT_RTSP_CLIENT_CSEQ, atoi((const char *)value.c_str()));
						break;
					case 194://CURLOPT_RTSP_SERVER_CSEQ:
						curl_easy_setopt(curl, CURLOPT_RTSP_SERVER_CSEQ, atoi((const char *)value.c_str()));
						break;
					case 178://CURLOPT_TFTP_BLKSIZE:
						curl_easy_setopt(curl, CURLOPT_TFTP_BLKSIZE, atoi((const char *)value.c_str()));
						break;
					case 48://CURLOPT_DIRLISTONLY:
						curl_easy_setopt(curl, CURLOPT_DIRLISTONLY, atoi((const char *)value.c_str()));
						break;
					case 50://CURLOPT_APPEND:
						curl_easy_setopt(curl, CURLOPT_APPEND, atoi((const char *)value.c_str()));
						break;
					case 106://CURLOPT_FTP_USE_EPRT:
						curl_easy_setopt(curl, CURLOPT_FTP_USE_EPRT, atoi((const char *)value.c_str()));
						break;
					case 85://CURLOPT_FTP_USE_EPSV:
						curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, atoi((const char *)value.c_str()));
						break;
					case 188://CURLOPT_FTP_USE_PRET:
						curl_easy_setopt(curl, CURLOPT_FTP_USE_PRET, atoi((const char *)value.c_str()));
						break;
					case 112://CURLOPT_FTP_RESPONSE_TIMEOUT:
						curl_easy_setopt(curl, CURLOPT_FTP_RESPONSE_TIMEOUT, atoi((const char *)value.c_str()));
						break;
					case 137://CURLOPT_FTP_SKIP_PASV_IP:
						curl_easy_setopt(curl, CURLOPT_FTP_SKIP_PASV_IP, atoi((const char *)value.c_str()));
						break;
					case 129://CURLOPT_FTPSSLAUTH:
						curl_easy_setopt(curl, CURLOPT_FTPSSLAUTH, atoi((const char *)value.c_str()));
						break;
					case 154://CURLOPT_FTP_SSL_CCC:
						curl_easy_setopt(curl, CURLOPT_FTP_SSL_CCC, atoi((const char *)value.c_str()));
						break;
					case 134://CURLOPT_FTP_ACCOUNT:
						curl_easy_setopt(curl, CURLOPT_FTP_ACCOUNT, atoi((const char *)value.c_str()));
						break;
					case 138://CURLOPT_FTP_FILEMETHOD:
						curl_easy_setopt(curl, CURLOPT_FTP_FILEMETHOD, atoi((const char *)value.c_str()));
						break;
					case 110://CURLOPT_FTP_CREATE_MISSING_DIRS:
						curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, atoi((const char *)value.c_str()));
						break;
					case 58://CURLOPT_AUTOREFERER:
						curl_easy_setopt(curl, CURLOPT_AUTOREFERER, atoi((const char *)value.c_str()));
						break;
					case 52://CURLOPT_FOLLOWLOCATION:
						curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, atoi((const char *)value.c_str()));
						break;
					case 105://CURLOPT_UNRESTRICTED_AUTH:
						curl_easy_setopt(curl, CURLOPT_UNRESTRICTED_AUTH, atoi((const char *)value.c_str()));
						break;
					case 68://CURLOPT_MAXREDIRS:
						curl_easy_setopt(curl, CURLOPT_MAXREDIRS, atoi((const char *)value.c_str()));
						break;
					case 161://CURLOPT_POSTREDIR:
						curl_easy_setopt(curl, CURLOPT_POSTREDIR, atoi((const char *)value.c_str()));
						break;
					case 60://CURLOPT_POSTFIELDSIZE:
						curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, atoi((const char *)value.c_str()));
						break;
					case 120://CURLOPT_POSTFIELDSIZE_LARGE:
						curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, atoi((const char *)value.c_str()));
						break;
					case 96://CURLOPT_COOKIESESSION:
						curl_easy_setopt(curl, CURLOPT_COOKIESESSION, atoi((const char *)value.c_str()));
						break;
					case 80://CURLOPT_HTTPGET:
						curl_easy_setopt(curl, CURLOPT_HTTPGET, atoi((const char *)value.c_str()));
						break;
					case 84://CURLOPT_HTTP_VERSION:
						curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, atoi((const char *)value.c_str()));
						break;
					case 158://CURLOPT_HTTP_CONTENT_DECODING:
						curl_easy_setopt(curl, CURLOPT_HTTP_CONTENT_DECODING, atoi((const char *)value.c_str()));
						break;
					case 157://CURLOPT_HTTP_TRANSFER_DECODING:
						curl_easy_setopt(curl, CURLOPT_HTTP_TRANSFER_DECODING, atoi((const char *)value.c_str()));
						break;
					case 136://CURLOPT_IGNORE_CONTENT_LENGTH:
						curl_easy_setopt(curl, CURLOPT_IGNORE_CONTENT_LENGTH, atoi((const char *)value.c_str()));
						break;
					case 111://CURLOPT_PROXYAUTH:
						curl_easy_setopt(curl, CURLOPT_PROXYAUTH, atoi((const char *)value.c_str()));
						break;
					case 206://CURLOPT_TLSAUTH_TYPE:
						curl_easy_setopt(curl, CURLOPT_TLSAUTH_TYPE, atoi((const char *)value.c_str()));
						break;
					case 107://CURLOPT_HTTPAUTH:
						curl_easy_setopt(curl, CURLOPT_HTTPAUTH, atoi((const char *)value.c_str()));
						break;
					case 51://CURLOPT_NETRC:
						curl_easy_setopt(curl, CURLOPT_NETRC, atoi((const char *)value.c_str()));
						break;
					case 215://CURLOPT_TCP_KEEPINTVL:
						curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, atoi((const char *)value.c_str()));
						break;
					case 214://CURLOPT_TCP_KEEPIDLE:
						curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, atoi((const char *)value.c_str()));
						break;
					case 213://CURLOPT_TCP_KEEPALIVE:
						curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, atoi((const char *)value.c_str()));
						break;
					case 171://CURLOPT_ADDRESS_SCOPE:
						curl_easy_setopt(curl, CURLOPT_ADDRESS_SCOPE, atoi((const char *)value.c_str()));
						break;
					case 121://CURLOPT_TCP_NODELAY:
						curl_easy_setopt(curl, CURLOPT_TCP_NODELAY, atoi((const char *)value.c_str()));
						break;
					case 3://CURLOPT_PORT:
						curl_easy_setopt(curl, CURLOPT_PORT, atoi((const char *)value.c_str()));
						break;
					case 98://CURLOPT_BUFFERSIZE:
						curl_easy_setopt(curl, CURLOPT_BUFFERSIZE, atoi((const char *)value.c_str()));
						break;
					case 92://CURLOPT_DNS_CACHE_TIMEOUT:
						curl_easy_setopt(curl, CURLOPT_DNS_CACHE_TIMEOUT, atoi((const char *)value.c_str()));
						break;
					case 140://CURLOPT_LOCALPORTRANGE:
						curl_easy_setopt(curl, CURLOPT_LOCALPORTRANGE, atoi((const char *)value.c_str()));
						break;
					case 139://CURLOPT_LOCALPORT:
						curl_easy_setopt(curl, CURLOPT_LOCALPORT, atoi((const char *)value.c_str()));
						break;
					case 180://CURLOPT_SOCKS5_GSSAPI_NEC:
						curl_easy_setopt(curl, CURLOPT_SOCKS5_GSSAPI_NEC, atoi((const char *)value.c_str()));
						break;
					case 61://CURLOPT_HTTPPROXYTUNNEL:
						curl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, atoi((const char *)value.c_str()));
						break;
					case 101://CURLOPT_PROXYTYPE:
						curl_easy_setopt(curl, CURLOPT_PROXYTYPE, atoi((const char *)value.c_str()));
						break;
					case 59://CURLOPT_PROXYPORT:
						curl_easy_setopt(curl, CURLOPT_PROXYPORT, atoi((const char *)value.c_str()));
						break;
					case 182://CURLOPT_REDIR_PROTOCOLS:
						curl_easy_setopt(curl, CURLOPT_REDIR_PROTOCOLS, atoi((const char *)value.c_str()));
						break;
					case 181://CURLOPT_PROTOCOLS:
						curl_easy_setopt(curl, CURLOPT_PROTOCOLS, atoi((const char *)value.c_str()));
						break;
					case 54://CURLOPT_PUT:
						curl_easy_setopt(curl, CURLOPT_PUT, atoi((const char *)value.c_str()));
						break;
					case 47://CURLOPT_POST:
						curl_easy_setopt(curl, CURLOPT_POST, atoi((const char *)value.c_str()));
						break;
					case 46://CURLOPT_UPLOAD:
						curl_easy_setopt(curl, CURLOPT_UPLOAD, atoi((const char *)value.c_str()));
						break;
					case 187://CURLOPT_MAIL_RCPT
						
						for(size_t p = 0, n; p <= value.length(); p = n + 1){
							
							n = value.find_first_of((const uint8_t *)",", p);
							if(n == CUTF8String::npos) n = value.length();
							CUTF8String v = value.substr(p, n - p);
							values_CURLOPT_MAIL_RCPT = curl_slist_append(values_CURLOPT_MAIL_RCPT, (const char *)v.c_str());
							
						}
						
						if(values_CURLOPT_MAIL_RCPT) curl_easy_setopt(curl, CURLOPT_MAIL_RCPT, values_CURLOPT_MAIL_RCPT);
						
						break;
					case 28://CURLOPT_QUOTE
						
						for(size_t p = 0, n; p <= value.length(); p = n + 1){
							
							n = value.find_first_of((const uint8_t *)",", p);
							if(n == CUTF8String::npos) n = value.length();
							CUTF8String v = value.substr(p, n - p);
							values_CURLOPT_QUOTE = curl_slist_append(values_CURLOPT_QUOTE, (const char *)v.c_str());
							
						}
						
						if(values_CURLOPT_QUOTE) curl_easy_setopt(curl, CURLOPT_QUOTE, values_CURLOPT_QUOTE);
						
						break;
					case 39://CURLOPT_POSTQUOTE
						
						for(size_t p = 0, n; p <= value.length(); p = n + 1){
							
							n = value.find_first_of((const uint8_t *)",", p);
							if(n == CUTF8String::npos) n = value.length();
							CUTF8String v = value.substr(p, n - p);
							values_CURLOPT_POSTQUOTE = curl_slist_append(values_CURLOPT_POSTQUOTE, (const char *)v.c_str());
							
						}
						
						if(values_CURLOPT_POSTQUOTE) curl_easy_setopt(curl, CURLOPT_POSTQUOTE, values_CURLOPT_POSTQUOTE);
						
						break;
					case 93://CURLOPT_PREQUOTE
						
						for(size_t p = 0, n; p <= value.length(); p = n + 1){
							
							n = value.find_first_of((const uint8_t *)",", p);
							if(n == CUTF8String::npos) n = value.length();
							CUTF8String v = value.substr(p, n - p);
							values_CURLOPT_PREQUOTE = curl_slist_append(values_CURLOPT_PREQUOTE, (const char *)v.c_str());
							
						}
						
						if(values_CURLOPT_PREQUOTE) curl_easy_setopt(curl, CURLOPT_PREQUOTE, values_CURLOPT_PREQUOTE);
						
						break;
					case 203://CURLOPT_RESOLVE
						
						for(size_t p = 0, n; p <= value.length(); p = n + 1){
							
							n = value.find_first_of((const uint8_t *)",", p);
							if(n == CUTF8String::npos) n = value.length();
							CUTF8String v = value.substr(p, n - p);
							values_CURLOPT_RESOLVE = curl_slist_append(values_CURLOPT_RESOLVE, (const char *)v.c_str());
							
						}
						
						if(values_CURLOPT_RESOLVE) curl_easy_setopt(curl, CURLOPT_RESOLVE, values_CURLOPT_RESOLVE);
						
						break;
					case 104://CURLOPT_HTTP200ALIASES
						
						for(size_t p = 0, n; p <= value.length(); p = n + 1){
							
							n = value.find_first_of((const uint8_t *)",", p);
							if(n == CUTF8String::npos) n = value.length();
							CUTF8String v = value.substr(p, n - p);
							values_CURLOPT_HTTP200ALIASES = curl_slist_append(values_CURLOPT_HTTP200ALIASES, (const char *)v.c_str());
							
						}
						
						if(values_CURLOPT_HTTP200ALIASES) curl_easy_setopt(curl, CURLOPT_HTTP200ALIASES, values_CURLOPT_HTTP200ALIASES);
						
						break;
					case 36://CURLOPT_CUSTOMREQUEST:
						curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, value.c_str());
						break;
					case 102://CURLOPT_ACCEPT_ENCODING:
						curl_easy_setopt(curl, CURLOPT_ACCEPT_ENCODING, value.c_str());
						break;
					case 118://CURLOPT_NETRC_FILE:
						curl_easy_setopt(curl, CURLOPT_NETRC_FILE, value.c_str());
						break;
					case 135://CURLOPT_COOKIELIST:
						curl_easy_setopt(curl, CURLOPT_COOKIELIST, value.c_str());
						break;
					case 147://CURLOPT_FTP_ALTERNATIVE_TO_USE:
						curl_easy_setopt(curl, CURLOPT_FTP_ALTERNATIVE_TO_USER, value.c_str());
						break;
					case 152://CURLOPT_SSH_PUBLIC_KEYFILE:
						curl_easy_setopt(curl, CURLOPT_SSH_PUBLIC_KEYFILE, value.c_str());
						break;
					case 153://CURLOPT_SSH_PRIVATE_KEYFILE:
						curl_easy_setopt(curl, CURLOPT_SSH_PRIVATE_KEYFILE, value.c_str());
						break;
					case 16://CURLOPT_REFERER:
						curl_easy_setopt(curl, CURLOPT_REFERER, value.c_str());
						break;
					case 162://CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
						curl_easy_setopt(curl, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, value.c_str());
						break;
					case 169://CURLOPT_CRLFILE:
						curl_easy_setopt(curl, CURLOPT_CRLFILE, value.c_str());
						break;
					case 17://CURLOPT_FTPPORT:
						curl_easy_setopt(curl, CURLOPT_FTPPORT, value.c_str());
						break;
					case 170://CURLOPT_ISSUERCERT:
						curl_easy_setopt(curl, CURLOPT_ISSUERCERT, value.c_str());
						break;
					case 173://CURLOPT_USERNAME:
						curl_easy_setopt(curl, CURLOPT_USERNAME, value.c_str());
						break;
					case 174://CURLOPT_PASSWORD:
						curl_easy_setopt(curl, CURLOPT_PASSWORD, value.c_str());
						break;
					case 175://CURLOPT_PROXYUSERNAME:
						curl_easy_setopt(curl, CURLOPT_PROXYUSERNAME, value.c_str());
						break;
					case 176://CURLOPT_PROXYPASSWORD:
						curl_easy_setopt(curl, CURLOPT_PROXYPASSWORD, value.c_str());
						break;
					case 177://CURLOPT_NOPROXY:
						curl_easy_setopt(curl, CURLOPT_NOPROXY, value.c_str());
						break;
					case 179://CURLOPT_SOCKS5_GSSAPI_SERVICE:
						curl_easy_setopt(curl, CURLOPT_SOCKS5_GSSAPI_SERVICE, value.c_str());
						break;
					case 18://CURLOPT_USERAGENT:
						curl_easy_setopt(curl, CURLOPT_USERAGENT, value.c_str());
						break;
					case 183://CURLOPT_SSH_KNOWNHOSTS:
						curl_easy_setopt(curl, CURLOPT_SSH_KNOWNHOSTS, value.c_str());
						break;
					case 186://CURLOPT_MAIL_FROM:
						curl_easy_setopt(curl, CURLOPT_MAIL_FROM, value.c_str());
						break;
					case 190://CURLOPT_RTSP_SESSION_ID:
						curl_easy_setopt(curl, CURLOPT_RTSP_SESSION_ID, value.c_str());
						break;
					case 191://CURLOPT_RTSP_STREAM_URI:
						curl_easy_setopt(curl, CURLOPT_RTSP_STREAM_URI, value.c_str());
						break;
					case 192://CURLOPT_RTSP_TRANSPORT:
						curl_easy_setopt(curl, CURLOPT_RTSP_TRANSPORT, value.c_str());
						break;
					case 197://CURLOPT_WILDCARDMATCH:
						curl_easy_setopt(curl, CURLOPT_WILDCARDMATCH, value.c_str());
						break;
					case 204://CURLOPT_TLSAUTH_USERNAME:
						curl_easy_setopt(curl, CURLOPT_TLSAUTH_USERNAME, value.c_str());
						break;
					case 205://CURLOPT_TLSAUTH_PASSWORD:
						curl_easy_setopt(curl, CURLOPT_TLSAUTH_PASSWORD, value.c_str());
						break;
					case 207://CURLOPT_TRANSFER_ENCODING:
						curl_easy_setopt(curl, CURLOPT_TRANSFER_ENCODING, value.c_str());
						break;
					case 217://CURLOPT_MAIL_AUTH:
						curl_easy_setopt(curl, CURLOPT_MAIL_AUTH, value.c_str());
						break;
					case 25://CURLOPT_SSLCERT:
						curl_easy_setopt(curl, CURLOPT_SSLCERT, value.c_str());
						break;
					case 26://CURLOPT_KEYPASSWD:
						curl_easy_setopt(curl, CURLOPT_KEYPASSWD, value.c_str());
						break;
					case 31://CURLOPT_COOKIEFILE:
						curl_easy_setopt(curl, CURLOPT_COOKIEFILE, value.c_str());
						break;
					case 4://CURLOPT_PROXY:
						curl_easy_setopt(curl, CURLOPT_PROXY, value.c_str());
						break;
					case 5://CURLOPT_USERPWD:
						curl_easy_setopt(curl, CURLOPT_USERPWD, value.c_str());
						break;
					case 6://CURLOPT_PROXYUSERPWD:
						curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, value.c_str());
						break;
					case 62://CURLOPT_INTERFACE:
						curl_easy_setopt(curl, CURLOPT_INTERFACE, value.c_str());
						break;
					case 63://CURLOPT_KRBLEVEL:
						curl_easy_setopt(curl, CURLOPT_KRBLEVEL, value.c_str());
						break;
					case 65://CURLOPT_CAINFO:
						curl_easy_setopt(curl, CURLOPT_CAINFO, value.c_str());
						break;
					case 7://CURLOPT_RANGE:
						curl_easy_setopt(curl, CURLOPT_RANGE, value.c_str());
						break;
					case 76://CURLOPT_RANDOM_FILE:
						curl_easy_setopt(curl, CURLOPT_RANDOM_FILE, value.c_str());
						break;
					case 77://CURLOPT_EGDSOCKET:
						curl_easy_setopt(curl, CURLOPT_EGDSOCKET, value.c_str());
						break;
					case 82://CURLOPT_COOKIEJAR:
						curl_easy_setopt(curl, CURLOPT_COOKIEJAR, value.c_str());
						break;
					case 83://CURLOPT_SSL_CIPHER_LIST:
						curl_easy_setopt(curl, CURLOPT_SSL_CIPHER_LIST, value.c_str());
						break;
					case 86://CURLOPT_SSLCERTTYPE:
						curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, value.c_str());
						break;
					case 87://CURLOPT_SSLKEY:
						curl_easy_setopt(curl, CURLOPT_SSLKEY, value.c_str());
						break;
					case 88://CURLOPT_SSLKEYTYPE:
						curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, value.c_str());
						break;
					case 89://CURLOPT_SSLENGINE:
						curl_easy_setopt(curl, CURLOPT_SSLENGINE, value.c_str());
						break;
					default:
						curl_easy_setopt(curl, option, value.c_str());
						break;
				}
			}
		}
		
		if(values_CURLOPT_HTTPHEADER) curl_easy_setopt(curl, CURLOPT_HTTPHEADER, values_CURLOPT_HTTPHEADER);
		
		void (*_PA_YieldAbsolute)(void) = PA_YieldAbsolute;
		
		curl_easy_setopt(curl, CURLOPT_READFUNCTION, _cURL_read_data);
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, _cURL_write_data);
		
		if(!multi)
		{
			Param1Url.fromParamAtIndex(pParams, 1);
			Param4InData.fromParamAtIndex(pParams, 4);
			
			curl_easy_setopt(curl, CURLOPT_READDATA, &Param4InData);
			curl_easy_setopt(curl, CURLOPT_WRITEDATA, &Param5OutData);
			
			if(!inFileSize)
			{
				curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, Param4InData.getBytesLength());
			}
			
			CUTF8String url;
			Param1Url.copyUTF8String(&url);
			curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
			error = curl_easy_perform_with_yield(curl, _PA_YieldAbsolute);
			returnValue.setIntValue(error);
			
			getInfo(curl, Param6Info);
			
		}else
		{
#ifndef PLUGIN_SDK_v11
			Param1Urls.fromParamAtIndex(pParams, 1);
			
			Param6Infos.setSize(0);
			Param7Errors.setSize(0);
			Param4 = ((PA_Variable *)pParams[3]);//$4
			Param5 = PA_CreateVariable(eVK_ArrayBlob);
		
			for(unsigned int i = 0; i < Param1Urls.getSize(); ++i)
			{
				CUTF8String url;
				Param1Urls.copyUTF8StringAtIndex(&url, i);
				C_BLOB Param4InData, Param5OutData;
				
				error = CURLE_OK;
				
				if(url.size())
				{
					if((Param4->fType == eVK_ArrayBlob) && (PA_GetArrayNbElements(*Param4) <= i))
					{
						PA_Blob param4_blob = PA_GetBlobInArray(*Param4, i);
						void *param4_buf = (void *)PA_LockHandle(param4_blob.fHandle);
						PA_long32 param4_len = param4_blob.fSize;
						Param4InData.setBytes((const uint8_t *)param4_buf, param4_len);
						PA_UnlockHandle(param4_blob.fHandle);
					}else
					{
						Param4InData.setBytes(NULL, 0);
					}
					
					curl_easy_setopt(curl, CURLOPT_READDATA, &Param4InData);
					curl_easy_setopt(curl, CURLOPT_WRITEDATA, &Param5OutData);
					curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
					
					error = curl_easy_perform_with_yield(curl, _PA_YieldAbsolute);
					
				}else
				{
					Param5OutData.setBytes(NULL, 0);
				}
				
				Param7Errors.appendIntValue(error);
				
				PA_ResizeArray(&Param5, i);
				PA_Variable param5_element = PA_CreateVariable(eVK_Blob);
				PA_SetBlobVariable(&param5_element, (void *)Param5OutData.getBytesPtr(), Param5OutData.getBytesLength());
				PA_SetBlobInArray(Param5, i, param5_element.uValue.fBlob);

				getInfo(curl, Param6Infos);

			}

#endif
		}
		
		//cleanup
		if(values_CURLOPT_MAIL_RCPT) curl_slist_free_all(values_CURLOPT_MAIL_RCPT);
		if(values_CURLOPT_QUOTE) curl_slist_free_all(values_CURLOPT_QUOTE);
		if(values_CURLOPT_POSTQUOTE) curl_slist_free_all(values_CURLOPT_POSTQUOTE);
		if(values_CURLOPT_PREQUOTE) curl_slist_free_all(values_CURLOPT_PREQUOTE);
		if(values_CURLOPT_RESOLVE) curl_slist_free_all(values_CURLOPT_RESOLVE);
		if(values_CURLOPT_HTTP200ALIASES) curl_slist_free_all(values_CURLOPT_HTTP200ALIASES);
		if(values_CURLOPT_HTTPHEADER) curl_slist_free_all(values_CURLOPT_HTTPHEADER);
		if(post_CURLOPT_HTTPPOST) curl_formfree(post_CURLOPT_HTTPPOST);
		
		curl_easy_cleanup(curl);
		
		std::map<uint32_t, uint32_t>::iterator pos;
		std::map<uint32_t, long>::iterator lpos;
		std::map<uint32_t, CUTF16String>::iterator upos;
		
#if VERSIONMAC
		std::map<uint32_t, CUTF8String>::iterator ppos;
#else
		std::map<uint32_t, CUTF16String>::iterator ppos;
#endif
		
		pos = _curl_write_method_ids.find(processId);
		if(pos != _curl_write_method_ids.end()) _curl_write_method_ids.erase(pos);
		
		pos = _curl_read_method_ids.find(processId);
		if(pos != _curl_read_method_ids.end()) _curl_read_method_ids.erase(pos);
		
		pos = _curl_debug_method_ids.find(processId);
		if(pos != _curl_debug_method_ids.end()) _curl_debug_method_ids.erase(pos);
		
		pos = _curl_header_method_ids.find(processId);
		if(pos != _curl_header_method_ids.end()) _curl_header_method_ids.erase(pos);
		
		pos = _curl_progress_method_ids.find(processId);
		if(pos != _curl_progress_method_ids.end()) _curl_progress_method_ids.erase(pos);
		
		upos = _curl_write_method_names.find(processId);
		if(upos != _curl_write_method_names.end()) _curl_write_method_names.erase(upos);
		
		upos = _curl_read_method_names.find(processId);
		if(upos != _curl_read_method_names.end()) _curl_read_method_names.erase(upos);
		
		upos = _curl_debug_method_names.find(processId);
		if(upos != _curl_debug_method_names.end()) _curl_debug_method_names.erase(upos);
		
		upos = _curl_header_method_names.find(processId);
		if(upos != _curl_header_method_names.end()) _curl_header_method_names.erase(upos);
		
		upos = _curl_progress_method_names.find(processId);
		if(upos != _curl_progress_method_names.end()) _curl_progress_method_names.erase(upos);
		
		pos = _curl_progress_ids.find(processId);
		if(pos != _curl_progress_ids.end()) _curl_progress_ids.erase(pos);
		
		lpos = _curl_input_positions.find(processId);
		if(lpos != _curl_input_positions.end()) _curl_input_positions.erase(lpos);
		
		ppos = _curl_input_paths.find(processId);
		if(ppos != _curl_input_paths.end()) _curl_input_paths.erase(ppos);
		
		ppos = _curl_output_paths.find(processId);
		if(ppos != _curl_output_paths.end()) _curl_output_paths.erase(ppos);
	}
	
	if(multi)
	{
		PA_SetVariableParameter(params, 5, Param5, 0);
		Param6Infos.toParamAtIndex(pParams, 6);
		Param7Errors.toParamAtIndex(pParams, 7);
	}else
	{
		PA_SetBlobParameter(params, 5, (void *)Param5OutData.getBytesPtr(), Param5OutData.getBytesLength());
		Param6Info.toParamAtIndex(pParams, 6);
		returnValue.setReturn(pResult);
	}
	
}

#pragma mark Tools

void cURL_Escape_url(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

    CURL *curl = curl_easy_init();
    
    if(curl){
        
        CUTF8String srcUrl;
        Param1.copyUTF8String(&srcUrl);
        
        char *escapedUrl = curl_easy_escape(curl, (char *)srcUrl.c_str(), (int)srcUrl.size());
        
        if(escapedUrl){
            CUTF8String dstUrl;		
            dstUrl = CUTF8String((const uint8_t *)escapedUrl);
            returnValue.setUTF8String(&dstUrl);		
        }
        
        curl_free(escapedUrl);
        curl_easy_cleanup(curl);	
    }

	returnValue.setReturn(pResult);
}

void cURL_Unescape_url(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

    CURL *curl = curl_easy_init();
    
    if(curl){
        
        CUTF8String srcUrl;
        Param1.copyUTF8String(&srcUrl);
        
        int outLength;
        char *escapedUrl = curl_easy_unescape(curl, (char *)srcUrl.c_str(), (int)srcUrl.size(), &outLength);
        
        CUTF8String dstUrl;		
        dstUrl = CUTF8String((const uint8_t *)escapedUrl, outLength);
        returnValue.setUTF8String(&dstUrl);
        
        curl_free(escapedUrl);
        curl_easy_cleanup(curl);	
    }

	returnValue.setReturn(pResult);
}

void cURL_Get_version(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

    CUTF8String version = (const uint8_t *)curl_version();
    returnValue.setUTF8String(&version);

	returnValue.setReturn(pResult);
}

//TODO: use C_REAL?

void cURL_Get_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

    CUTF8String datestring;
    Param1.copyUTF8String(&datestring);
    
    time_t date = curl_getdate((char *)datestring.c_str(), NULL);
    
    switch (date) {
        case -1:
            returnValue.setIntValue(0);
            break;
        case  0x7FFFFFFF:
            returnValue.setIntValue(0);
            break;			
        default:
            Param2.setIntValue((int)date);
            returnValue.setIntValue(1);			
            break;
    }

	Param2.toParamAtIndex(pParams, 2);    
	returnValue.setReturn(pResult);
}

void cURL_Get_executable(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

#if VERSIONMAC 
    NSBundle *b = [NSBundle bundleWithIdentifier:@"com.4D.4DPlugin.miyako.cURL"];
    if(b){
        NSString *path = [[[b executablePath]stringByDeletingLastPathComponent]stringByAppendingPathComponent:@"curl"];
        returnValue.setUTF16String(path);
    }
#else
	wchar_t	fDrive[_MAX_DRIVE],
	fDir[_MAX_DIR],
	fName[_MAX_FNAME],
	fExt[_MAX_EXT];
	
	wchar_t thisPath[_MAX_PATH] = {0};
	wchar_t resourcesPath[_MAX_PATH] = {0};
	wchar_t srchilitePath[_MAX_PATH] = {0};
	HMODULE b = GetModuleHandleW(L"curl-4d.4dx");
	if(b){
		GetModuleFileNameW(b, thisPath, _MAX_PATH);
		_wsplitpath_s(thisPath, fDrive, fDir, fName, fExt);	
		std::wstring windowsPath = fDrive;
		windowsPath += fDir;
		windowsPath += L"curl.exe";
		returnValue.setUTF16String((const PA_Unichar *)windowsPath.c_str(), windowsPath.size());
	}

    
#endif    

	returnValue.setReturn(pResult);
}

